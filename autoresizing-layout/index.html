
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Autoresizing Layout</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=1b7f2db5dd">

    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="Max Kazakov">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Autoresizing Layout">
    <meta property="og:description" content="На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают
высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS
разработчиком, я тратил огромное количество времени на попытки понять принципы
работы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов,
который помогает iOS разработчику покрыть часть простых кейсов, связанных с
версткой. Цель данной — статьи поближе познакомимся с этим инструментом.

Способы верстки в iOS
На сегодняшний д">
    <meta property="og:url" content="http://localhost:2368/autoresizing-layout/">
    <meta property="article:published_time" content="2019-05-09T11:44:18.000Z">
    <meta property="article:modified_time" content="2019-05-10T18:49:03.000Z">
    <meta property="article:publisher" content="https://www.facebook.com/max.kazakov.376">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Autoresizing Layout">
    <meta name="twitter:description" content="На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают
высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS
разработчиком, я тратил огромное количество времени на попытки понять принципы
работы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов,
который помогает iOS разработчику покрыть часть простых кейсов, связанных с
версткой. Цель данной — статьи поближе познакомимся с этим инструментом.

Способы верстки в iOS
На сегодняшний д">
    <meta name="twitter:url" content="http://localhost:2368/autoresizing-layout/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Max Kazakov">
    <meta name="twitter:site" content="@maxxkazakov">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Max Kazakov",
        "logo": {
            "@type": "ImageObject",
            "url": "http://localhost:2368/favicon.ico",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Max Kazakov",
        "url": "http://localhost:2368/author/max/",
        "sameAs": []
    },
    "headline": "Autoresizing Layout",
    "url": "http://localhost:2368/autoresizing-layout/",
    "datePublished": "2019-05-09T11:44:18.000Z",
    "dateModified": "2019-05-10T18:49:03.000Z",
    "description": "На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают\nвысоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS\nразработчиком, я тратил огромное количество времени на попытки понять принципы\nработы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов,\nкоторый помогает iOS разработчику покрыть часть простых кейсов, связанных с\nверсткой. Цель данной — статьи поближе познакомимся с этим инструментом.\n\nСпособы верстки в iOS\nНа сегодняшний д",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368/"
    }
}
    </script>

    <meta name="generator" content="Ghost 2.22">
    <link rel="alternate" type="application/rss+xml" title="Max Kazakov" href="../rss/index.html">

</head>
<body class="post-template">

    <div class="site-wrapper">

        

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="../">Max Kazakov</a>
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="../">Home</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
                <a class="social-link social-link-fb" href="https://www.facebook.com/max.kazakov.376" title="Facebook" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
</a>
                <a class="social-link social-link-tw" href="https://twitter.com/maxxkazakov" title="Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
</a>
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/http://localhost:2368/rss/" title="RSS" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post no-image">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2019-05-09">9 May 2019</time>
                </section>
                <h1 class="post-full-title">Autoresizing Layout</h1>
            </header>


            <section class="post-full-content">
                <div class="post-content">
                    <p>На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS разработчиком, я тратил огромное количество времени на попытки понять принципы работы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов, который помогает iOS разработчику покрыть часть простых кейсов, связанных с версткой. Цель данной — статьи поближе познакомимся с этим инструментом.</p><h2 id="-ios">Способы верстки в iOS</h2><p>На сегодняшний день UIKit предоставляет разработчикам 2 способа управления версткой: ручной (или по-другому верстка на фреймах) и Autolayout.</p><p>Под ручной версткой понимается управление размерами и позицией view вручную, путем изменения свойств <em>frame (</em>либо <em>center</em> и <em>bounds). </em>Как правило, данный способ реализуется при помощи переопределения метода <em>layoutSubviews </em>UIView, на момент вызова которого, нам известно свойство bounds текущего экземпляра. В этом методе мы <em>вручную </em>определяем позицию и размеры дочерних вью.</p><p>Autolayout использует набор ограничений (constraints), которые описывают, как будут располагаться вью относительно друг друга. В отличие от ручного способа, здесь нет необходимости высчитывать <em>frame</em> каждый раз, когда в нашей верстке что-то изменилось, Autolayout сделает это за нас. Данный способ также допускает ручную настройку <em>frame</em> в случае, если мы хотим подкорректировать результат лейаута. Для этого нужно переопределить <em>layoutSubviews, </em>вызывать родительскую реализацию этого метода (здесь дочерние вью получат свои размеры из движка Autolayout), скорректировать фреймы дочерних вью.</p><p>Каждый из способов обладает своими преимуществами и недостатками, описание которых достойно отдельной статьи, мы же остановим наше внимание на Autoresizing.</p><h2 id="-autoresizing">Основные принципы Autoresizing</h2><p>Autoresizing работает всегда, когда мы решили использовать ручную верстку (и в некоторых случаях при использовании Autolayout, но об этом чуть позже). Autoresizing основан на двух основных понятиях: springs (струны) и struts (распорки). Перевод этих терминов точно отражает их смысл: springs — что-то, что растягивается, struts — что-то, что всегда имеет фиксированный размер. Данные понятия применимы к следующим <strong>параметрам разметки</strong>:<br>1) Внутренние — Width, Height. Описывают размер вью.<br>2) Внешние — Left, Right, Top, Bottom. Описывают положение вью внутри родителя — отступ от левого, правого, верхнего и нижнего края соответственно.</p><p>Рассмотрим простой пример того, как это работает. Допустим, у нас есть задача: необходимо, чтобы дочерняя вью всегда располагалась по центру родительской и пропорционально изменяла размер при изменении размера родителя (Рис. 1). Решением в данном случае будет установить struts для всех внешних параметров, и springs для всех внутренних параметров.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="../content/images/2019/05/center-resize.gif" class="kg-image"><figcaption>Рис. 1. Синий прямоугольник — родительская вью, красный — дочерняя.</figcaption></figure><!--kg-card-end: image--><p>Другой пример: необходимо разместить вью с фиксированным размером в правом нижнем углу родительской вью (Рис. 2). Для это необходимо установить struts для параметров Right и Bottom, а также для всех внутренних параметров, т.к. расстояния от нижнего и правого края до родителя и размер нашей вью строго зафиксированы. Также нужно установить strings для Left и Top, т.к. эти параметры будут изменяться при изменении размеров родительской вью.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="../content/images/2019/05/topleft.gif" class="kg-image"><figcaption>Рис. 2. Вью с фиксированным размером и привязкой к правому нижнему углу</figcaption></figure><!--kg-card-end: image--><h2 id="autoresizing-">Autoresizing в коде</h2><p>Единственный способ регулировать Autoresizing в коде — свойство <em>autoresizingMask </em>у UIView. Данное свойство имеет тип OptionSet со следующим набором опций:</p><!--kg-card-begin: markdown--><ul>
<li>flexibleLeftMargin</li>
<li>flexibleWidth</li>
<li>flexibleRightMargin</li>
<li>flexibleTopMargin</li>
<li>flexibleHeight</li>
<li>flexibleBottomMargin</li>
</ul>
<!--kg-card-end: markdown--><p>Как данное свойство соотносится со stings и struts, внешними и внутренними параметрами разметки? <em>Каждая опция в</em> <em>autoresizingMask — это strings для определенного параметра, а отсутствие опции — автоматически означает struts.</em></p><p>Теперь попробуем решить первую задачу с центрированием дочерней вью (Рис. 1). Для этого нам необходимо задать свойство autoresizingMask, как показано на фрагменте кода ниже. </p><!--kg-card-begin: markdown--><pre><code>    // Создаем родительскую view
    let v1 = UIView(frame: CGRect(x: 100, y: 250, width: 200, height: 200))
    v1.backgroundColor = .blue
    
    // Создаем дочернюю вью
    let v2 = UIView(frame: v1.bounds.insetBy(dx: 30, dy: 30))
    v2.backgroundColor = .red
    
    // Добавление в иерархию
    self.view.addSubview(v1)
    v1.addSubview(v2)
    
    // Устанавливаем autoresizing
    v2.autoresizingMask = [.flexibleWidth, .flexibleHeight]
</code></pre>
<!--kg-card-end: markdown--><p>Установив значение свойства [.flexibleWidth, .flexibleHeight], мы говорим, что хотим сделать изменяемые значения для параметров width и height (strings), а для остальных свойств оставить фиксированные значения (struts).</p><p>Вторая задача решается при помощи задания значения [.flexibleTopMargin, .flexibleLeftMargin]. Мы не указали в опциях размер, а также нижний и правый отступ, а значит, эти параметры будут оставаться постоянными (Рис. 2).</p><p>По умолчанию свойство autoresizingMasks является пустым. Что произойдет, если оставить значение по умолчанию? Дочерняя вью будет всегда сохранять фиксированные отступы сверху и слева, а также фиксированный размер, при этом расстояние снизу и справа будут меняться. Это означает, что пустой autoresizingMasks равносилен [.flexibleBottomMargin, .flexibleRightMargin].</p><h2 id="autoresizing-interface-builder">Autoresizing в Interface Builder</h2><p>Interface Builder также позволяет конфигурировать autoresizingMasks. Для этого необходимо перейти во вкладку Size Inspectors, редактор Autoresizing выглядит как показано на рисунке ниже.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="../content/images/2019/05/image.png" class="kg-image"><figcaption>Рис 3. Редактирование Autoresizing в Interface Builder</figcaption></figure><!--kg-card-end: image--><p>Здесь активные внешние параметры означают struts, неактивные — strings. Для внутренних параметров все ровно наоборот.</p><h2 id="translatesautoresizingmaskintoconstraints">translatesAutoresizingMaskIntoConstraints</h2><p>Вью начинает быть задействованной в расчете на Autolayout как только мы добавили ей или одной из ее дочерних вью constraint. В таком случае, если задать constraints только для дочерней вью, но не задавать для родительской, мы можем получить предупреждение, которое сообщает о том, что для родительской вью Autolayout не смог определить размер и позицию ("Position and size are ambiguous"). Такая ситуация могла возникнуть когда Autolayout только появился в iOS — новые вью верстались с использованием constraints, а старые оставались на ручном лейауте (он же Autoresizing, как мы выяснили ранее). Для того, чтобы избежать этого, разработчики Apple ввели свойство translatesAutoresizingMaskIntoConstraints. Если свойство имеет значение true, то для вью будут автоматически созданы constraints, которые однозначно определяют позицию и размер. Во View Hierarchy мы можем увидеть автоматически сгенерированные constraints.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="../content/images/2019/05/image-1.png" class="kg-image"><figcaption>Рис. 4. Автоматически сгенерированные constraints</figcaption></figure><!--kg-card-end: image--><p>Значение false отключает эту магию. При создании вью из кода — значение свойства — true, при создании из xib/storyboard — false. В Interface Builder свойство регулируется при помощи флага “Use Auto Layout", которое является инвертированным значением translatesAutoresizingMaskIntoConstraints.</p><p>Очень часто возникает ситуация, когда мы хотим создать нашу вью из кода и сверстать ее на Autolayout, т.е. явно задать ей constraints. Чтобы наши и автоматически сгенерированные constraints не конфликтовали, необходимо задать значение translatesAutoresizingMaskIntoConstraints в false.</p><h2 id="-">Заключение</h2><p>Очевидно, что с приходом Autolayout механизм Autoresizng утратил актуальность. Однако, его понимание необходимо как минимум, чтобы осознанно избегать конфликтов c constraints. Также данных механизм может быть полезен для простой верстки вью относительно родителя.</p>
                </div>
            </section>


            <footer class="post-full-footer">


                    
<section class="author-card">
        <span class="avatar-wrapper"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</span>
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/max/">Max Kazakov</a></h4>
            <p>Read <a href="../author/max/">more posts</a> by this author.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/max/">Read More</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">



        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="../">
            <span>Max Kazakov</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">Autoresizing Layout</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Autoresizing%20Layout&amp;url=http://localhost:2368/autoresizing-layout/" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:2368/autoresizing-layout/" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="../">Max Kazakov</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="../">Latest Posts</a>
                    <a href="https://www.facebook.com/max.kazakov.376" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/maxxkazakov" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script>
        var images = document.querySelectorAll('.kg-gallery-image img');
        images.forEach(function (image) {
            var container = image.closest('.kg-gallery-image');
            var width = image.attributes.width.value;
            var height = image.attributes.height.value;
            var ratio = width / height;
            container.style.flex = ratio + ' 1 0%';
        })
    </script>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/built/jquery.fitvids.js?v=1b7f2db5dd"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    

</body>
