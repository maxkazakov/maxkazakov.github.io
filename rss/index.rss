<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Max Kazakov</title><description>Блог iOS разработчика</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Max Kazakov</title><link>http://localhost:2368/</link></image><generator>Ghost 2.22</generator><lastBuildDate>Fri, 10 May 2019 18:40:20 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Autoresizing Layout</title><description>&lt;p&gt;На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS разработчиком, я тратил огромное количество времени на попытки понять принципы работы constraints, циклы лейаута и т.д. Autoresizing — один из инструментов, который помогает iOS разработчику покрыть&lt;/p&gt;</description><link>http://localhost:2368/autoresizing-layout/</link><guid isPermaLink="false">5cd4125f806356e203eb80c1</guid><dc:creator>Max Kazakov</dc:creator><pubDate>Thu, 09 May 2019 11:44:18 GMT</pubDate><content:encoded>&lt;p&gt;На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS разработчиком, я тратил огромное количество времени на попытки понять принципы работы constraints, циклы лейаута и т.д. Autoresizing — один из инструментов, который помогает iOS разработчику покрыть часть простых кейсов связанных с версткой. Цель данной статьи поближе познакомимся с этим инструментом.&lt;/p&gt;&lt;h2 id="-ios"&gt;Способы верстки в iOS&lt;/h2&gt;&lt;p&gt;На сегодняшний день UIKit предоставляет разработчикам 2 способа управления версткой: ручной (или по-другому верстка на фреймах) и Autolayout.&lt;/p&gt;&lt;p&gt;Под ручной версткой понимается управление размерами и позицией view вручную, путем изменения свойств &lt;em&gt;frame (&lt;/em&gt;либо &lt;em&gt;center&lt;/em&gt; и &lt;em&gt;bounds). &lt;/em&gt;Как правило, данный способ реализуется при помощи переопределения метода &lt;em&gt;layoutSubviews &lt;/em&gt;UIView, на момент вызова которого, нам известно свойство bounds текущего экземпляра. В этом методе мы &lt;em&gt;вручную &lt;/em&gt;определяем позицию и размеры дочерних вью.&lt;/p&gt;&lt;p&gt;Autolayout использует набор ограничений (constraints), которые описывают, как будут располагаться вью относительно друг друга. В отличие от ручного способа, здесь нет необходимости высчитывать &lt;em&gt;frame&lt;/em&gt; каждый раз, когда в нашей верстке что-то изменилось, Autolayout сделает это за нас. Данный способ также допускает ручную настройку &lt;em&gt;frame&lt;/em&gt; в случае, если мы хотим подкорректировать результат лейаута. Для этого нужно переопределить &lt;em&gt;layoutSubviews, &lt;/em&gt;вызывать родительскую реализацию этого метода (здесь дочерние вью получат свои размеры из движка Autolayout), скорректировать фреймы дочерних вью.&lt;/p&gt;&lt;p&gt;Каждый из способов обладает своими преимуществами и недостатками, описание которых достойно отдельной статьи, мы же остановим наше внимание на Autoresizing.&lt;/p&gt;&lt;h2 id="-autoresizing"&gt;Основные принципы Autoresizing&lt;/h2&gt;&lt;p&gt;Autoresizing работает всегда, когда мы решили использовать ручную верстку (и в некоторых случаях при использовании Autolayout, но об этом чуть позже). Autoresizing основан на двух основных понятиях: springs (струны) и struts (распорки). Перевод этих терминов точно отражает их смысл: springs — что-то, что растягивается, struts — что-то, что всегда имеет фиксированный размер. Данные понятия применимы к следующим &lt;strong&gt;параметрам разметки&lt;/strong&gt;:&lt;br&gt;1) Внутренние — Width, Height. Описывают размер вью.&lt;br&gt;2) Внешние — Left, Right, Top, Bottom. Описывают положение вью внутри родителя — отступ от левого, правого, верхнего и нижнего края соответственно.&lt;/p&gt;&lt;p&gt;Рассмотрим простой пример того, как это работает. Допустим, у нас есть задача: необходимо, чтобы дочерняя вью всегда располагалась по центру родительской и пропорционально изменяла размер при изменении размера родителя (Рис. 1). Решением в данном случае будет установить struts для всех внешних параметров, и springs для всех внутренних параметров.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/center-resize.gif" class="kg-image"&gt;&lt;figcaption&gt;Рис. 1. Синий прямоугольник — родительская вью, красный — дочерняя.&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Другой пример: необходимо разместить вью с фиксированным размером в правом нижнем углу родительской вью (Рис. 2). Для это необходимо установить struts для параметров Right и Bottom, а также для всех внутренних параметров, т.к. расстояния от нижнего и правого края до родителя и размер нашей вью строго зафиксированы. Также нужно установить strings для Left и Top, т.к. эти параметры будут изменяться при изменении размеров родительской вью.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/topleft.gif" class="kg-image"&gt;&lt;figcaption&gt;Рис. 2. Вью с фиксированным размером и привязкой к правому нижнему углу&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;h2 id="autoresizing-"&gt;Autoresizing в коде&lt;/h2&gt;&lt;p&gt;Единственный способ регулировать Autoresizing в коде — свойство &lt;em&gt;autoresizingMask &lt;/em&gt;у UIView. Данное свойство имеет тип OptionSet со следующим набором опций:&lt;/p&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;ul&gt;
&lt;li&gt;flexibleLeftMargin&lt;/li&gt;
&lt;li&gt;flexibleWidth&lt;/li&gt;
&lt;li&gt;flexibleRightMargin&lt;/li&gt;
&lt;li&gt;flexibleTopMargin&lt;/li&gt;
&lt;li&gt;flexibleHeight&lt;/li&gt;
&lt;li&gt;flexibleBottomMargin&lt;/li&gt;
&lt;/ul&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;p&gt;Как данное свойство соотносится со stings и struts, внешними и внутренними параметрами разметки? &lt;em&gt;Каждая опция в&lt;/em&gt; &lt;em&gt;autoresizingMask — это strings для определенного параметра, а отсутствие опции — автоматически означает struts.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Теперь попробуем решить первую задачу с центрированием дочерней вью (Рис. 1). Для этого нам необходимо задать свойство autoresizingMask, как показано на фрагменте кода ниже. &lt;/p&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;pre&gt;&lt;code&gt;    // Создаем родительскую view
    let v1 = UIView(frame: CGRect(x: 100, y: 250, width: 200, height: 200))
    v1.backgroundColor = .blue
    
    // Создаем дочернюю вью
    let v2 = UIView(frame: v1.bounds.insetBy(dx: 30, dy: 30))
    v2.backgroundColor = .red
    
    // Добавление в иерархию
    self.view.addSubview(v1)
    v1.addSubview(v2)
    
    // Устанавливаем autoresizing
    v2.autoresizingMask = [.flexibleWidth, .flexibleHeight]
&lt;/code&gt;&lt;/pre&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;p&gt;Установив значение свойства [.flexibleWidth, .flexibleHeight], мы говорим, что хотим сделать изменяемые значения для параметров width и height (strings), а для остальных свойств оставить фиксированные значения (struts).&lt;/p&gt;&lt;p&gt;Вторая задача решается при помощи задания значения [.flexibleTopMargin, .flexibleLeftMargin]. Мы не указали в опциях размер, а также нижний и правый отступ, а значит, эти параметры будут оставаться постоянными (Рис. 2).&lt;/p&gt;&lt;p&gt;По умолчанию свойство autoresizingMasks является пустым. Что произойдет, если оставить значение по умолчанию? Дочерняя вью будет всегда сохранять фиксированные отступы сверху и слева, а также фиксированный размер, при этом расстояние снизу и справа будут меняться. Это означает, что пустой autoresizingMasks равносилен [.flexibleBottomMargin, .flexibleRightMargin].&lt;/p&gt;&lt;h2 id="autoresizing-interface-builder"&gt;Autoresizing в Interface Builder&lt;/h2&gt;&lt;p&gt;Interface Builder также позволяет конфигурировать autoresizingMasks. Для этого необходимо перейти во вкладку Size Inspectors, редактор Autoresizing выглядит как показано на рисунке ниже.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/image.png" class="kg-image"&gt;&lt;figcaption&gt;Рис 3. Редактирование Autoresizing в Interface Builder&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Здесь активные внешние параметры означают struts, неактивные — strings. Для внутренних параметров все ровно наоборот.&lt;/p&gt;&lt;h2 id="translatesautoresizingmaskintoconstraints"&gt;translatesAutoresizingMaskIntoConstraints&lt;/h2&gt;&lt;p&gt;Вью начинает быть задействованной в расчете на Autolayout как только мы добавили ей или одной из ее дочерних вью constraint. В таком случае, если задать constraints только для дочерней вью, но не задавать для родительской, мы можем получить предупреждение, которое сообщает о том, что для родительской вью Autolayout не смог определить размер и позицию ("Position and size are ambiguous"). Такая ситуация могла возникнуть когда Autolayout только появился в iOS — новые вью верстались с использованием constraints, а старые оставались на ручном лейауте (он же Autoresizing, как мы выяснили ранее). Для того, чтобы избежать этого, разработчики Apple ввели свойство translatesAutoresizingMaskIntoConstraints. Если свойство имеет значение true, то для вью будут автоматически созданы constraints, которые однозначно определяют позицию и размер. Во View Hierarchy мы можем увидеть автоматически сгенерированные constraints.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/image-1.png" class="kg-image"&gt;&lt;figcaption&gt;Рис. 4. Автоматически сгенерированные constraints&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Значение false отключает эту магию. При создании вью из кода — значение свойства — true, при создании из xib/storyboard — false. В Interface Builder свойство регулируется при помощи флага “Use Auto Layout", которое является инвертированным значением translatesAutoresizingMaskIntoConstraints.&lt;/p&gt;&lt;p&gt;Очень часто возникает ситуация, когда мы хотим создать нашу вью из кода и сверстать ее на Autolayout, т.е. явно задать ей constraints. Чтобы наши и автоматически сгенерированные constraints не конфликтовали, необходимо задать значение translatesAutoresizingMaskIntoConstraints в false.&lt;/p&gt;&lt;h2 id="-"&gt;Заключение&lt;/h2&gt;&lt;p&gt;Очевидно, что с приходом Autolayout механизм Autoresizng утратил актуальность. Однако, его понимание необходимо как минимум, чтобы осознанно избегать конфликтов c constraints. Также данных механизм может быть полезен для простой верстки вью относительно родителя.&lt;/p&gt;</content:encoded></item></channel></rss>