<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Max Kazakov</title><description>Блог iOS разработчика</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Max Kazakov</title><link>http://localhost:2368/</link></image><generator>Ghost 2.22</generator><lastBuildDate>Fri, 10 May 2019 11:23:27 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Autoresizing Layout</title><description>&lt;p&gt;Тут короткое вступление.&lt;/p&gt;&lt;h2 id="-ios"&gt;Способы верстки в iOS&lt;/h2&gt;&lt;p&gt;На сегодняшний день UIKit предоставляет разработчикам 2 способа управления версткой: ручной и Autolayout.&lt;br&gt;&lt;/p&gt;&lt;p&gt;Ручной (верстка на фреймах) — управление размерами и позицией view вручную, путем изменения свойств &lt;em&gt;frame(&lt;/em&gt;либо &lt;em&gt;center&lt;/em&gt; и &lt;em&gt;bounds). &lt;/em&gt;Как правило данный способ реализуется при помощи переопределения метода &lt;em&gt;layoutSubviews — &lt;/em&gt;метод UIView,&lt;/p&gt;</description><link>http://localhost:2368/autoresizing-masks/</link><guid isPermaLink="false">5cd4125f806356e203eb80c1</guid><dc:creator>Max Kazakov</dc:creator><pubDate>Thu, 09 May 2019 11:44:18 GMT</pubDate><content:encoded>&lt;p&gt;Тут короткое вступление.&lt;/p&gt;&lt;h2 id="-ios"&gt;Способы верстки в iOS&lt;/h2&gt;&lt;p&gt;На сегодняшний день UIKit предоставляет разработчикам 2 способа управления версткой: ручной и Autolayout.&lt;br&gt;&lt;/p&gt;&lt;p&gt;Ручной (верстка на фреймах) — управление размерами и позицией view вручную, путем изменения свойств &lt;em&gt;frame(&lt;/em&gt;либо &lt;em&gt;center&lt;/em&gt; и &lt;em&gt;bounds). &lt;/em&gt;Как правило данный способ реализуется при помощи переопределения метода &lt;em&gt;layoutSubviews — &lt;/em&gt;метод UIView, который вызывается системой в тот момент, когда нам известны свойство bounds текущего экземпляра. В этом методе мы &lt;em&gt;вручную &lt;/em&gt;определяем позицию и размеры дочерних вью.&lt;/p&gt;&lt;p&gt;&lt;br&gt;Autolayout использует набор ограничений (constraints), которые описывают как будут располагаться вью относительно друг друга. В отличии от ручного способа, здесь нет необходимости высчитывать &lt;em&gt;frame&lt;/em&gt; каждый раз когда в нашей верстке что-то изменилось, Autolayout сделает это за нас. Данный способ также допускает ручную настройку &lt;em&gt;frame&lt;/em&gt; в случае, если мы хотим подкорректировать результат лейаута. Для этого нужно переопределить &lt;em&gt;layoutSubviews, &lt;/em&gt;вызывать родительскую реализацию этого метода (здесь дочерние вью получат свои размеры из движка Autolayout), скорректировать фреймы дочерних вью.&lt;/p&gt;&lt;p&gt;Каждый из способов обладает своими преимуществами и недостатками, описание которых достойно отдельно статьи, мы же остановим наше внимание на Autoresizing.&lt;/p&gt;&lt;h2 id="-autoresizing"&gt;Основные принципы Autoresizing&lt;/h2&gt;&lt;p&gt;Где среди перечисленных способов находится Autoresizing? Autoresizing работает всегда, когда мы решили использовать ручную верстку (и в некоторых случаях при использовании Autolayout, но об этом чуть позже). Autoresizing основан на двух основных понятиях: springs (струны) и struts (распорки). Перевод этих терминов точно отражает их смысл: springs — что-то, что растягивается, struts — что-то, что всегда имеет фиксированный размер. Данные понятия применимы к следующим &lt;strong&gt;параметрам разметки&lt;/strong&gt;:&lt;br&gt;1) Внутренние — Width, Height. Описывают размер вью.&lt;br&gt;2) Внешние — Left, Right, Top, Bottom. Описывают положение вью внутри родителя — отступ от левого, правого, верхнего и нижнего края соответственно.&lt;/p&gt;&lt;p&gt;Рассмотрим простой пример того, как это работает. Допустим у нас есть задача — необходимо чтобы дочерняя вью всегда располагалась по центру родительской и пропорционально изменяла размер при изменении размера родителя (Рис. 1). Решением в данном случае будет установить struts для всех внешних параметров, и установить springs для всех внутренних параметров.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/center-resize.gif" class="kg-image"&gt;&lt;figcaption&gt;Рис. 1. Синий прямоугольник — родительская вью, красный — дочерняя.&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Другой пример — необходимо разместить вью с фиксированным размером в правом нижнем углу родительской вью (Рис. 2). Для это необходимо установить struts для параметров Right и Bottom, а также для всех внутренних параметров, т.к. расстояния от нижнего и правого края до родителя и размер нашей вью строго зафиксированы. Также нужно установить strings для Left и Top, т.к. эти параметры будут изменяться при изменении размеров родительской вью.&lt;/p&gt;&lt;!--kg-card-begin: image--&gt;&lt;figure class="kg-card kg-image-card kg-card-hascaption"&gt;&lt;img src="http://localhost:2368/content/images/2019/05/topleft.gif" class="kg-image"&gt;&lt;figcaption&gt;Рис. 2. Вью с фиксированным размером и привязанная к правому нижнему углу&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--kg-card-end: image--&gt;&lt;p&gt;Очень важно на данном этапе разобраться со всеми перечисленными параметрами, так как интерфейсы для управления ими, которые мы рассмотрим далее, могут немного запутать.&lt;/p&gt;&lt;h2 id="autoresizing-"&gt;Autoresizing в коде&lt;/h2&gt;&lt;p&gt;Единственный способ регулировать Autoresizing в коде — свойство &lt;em&gt;autoresizingMask &lt;/em&gt;у UIView. Данное свойство имеет тип OptionSet со следующим набором опций:&lt;/p&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;ul&gt;
&lt;li&gt;flexibleLeftMargin&lt;/li&gt;
&lt;li&gt;flexibleWidth&lt;/li&gt;
&lt;li&gt;flexibleRightMargin&lt;/li&gt;
&lt;li&gt;flexibleTopMargin&lt;/li&gt;
&lt;li&gt;flexibleHeight&lt;/li&gt;
&lt;li&gt;flexibleBottomMargin&lt;/li&gt;
&lt;/ul&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;p&gt;Как данное свойство соотносится со stings и struts, внешними и внутренними параметрами разметки? &lt;em&gt;Каждая опция в&lt;/em&gt; &lt;em&gt;autoresizingMask — это strings для определенного параметра, а отсутствие опции — автоматически означает struts.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Теперь попробуем решить первую задачу с центрированием дочерней вью (Рис. 1). Для этого нам необходимо задать свойство autoresizing как показано на фрагменте кода ниже. &lt;/p&gt;&lt;!--kg-card-begin: markdown--&gt;&lt;pre&gt;&lt;code&gt;    // Создаем родительскую view
    let v1 = UIView(frame: CGRect(x: 100, y: 250, width: 200, height: 200))
    v1.backgroundColor = .blue
    
    // Создаем дочернюю вью
    let v2 = UIView(frame: v1.bounds.insetBy(dx: 30, dy: 30))
    v2.backgroundColor = .red
    
    // Добавление в иерархию
    self.view.addSubview(v1)
    v1.addSubview(v2)
    
    // Устанавливаем autoresizing
    v2.autoresizingMask = [.flexibleWidth, .flexibleHeight]
&lt;/code&gt;&lt;/pre&gt;
&lt;!--kg-card-end: markdown--&gt;&lt;p&gt;Установив значение свойства [.flexibleWidth, .flexibleHeight], мы говорим, что хотим сделать изменяемые значения для параметров width и height (strings), а для остальных свойств оставить фиксированные значения (struts).&lt;/p&gt;&lt;p&gt;Вторая задача решается при помощи задания значения [.flexibleTopMargin, .flexibleLeftMargin]. Мы не указали в опциях размер, а также нижний и правый отступ, а значит эти параметры будут оставаться постоянными (Рис. 2)&lt;/p&gt;&lt;p&gt;По умолчанию свойство autoresizingMasks является пустым. Что произойдет если оставить значение по умолчанию и изменить размер родителя? Дочерняя вью будет всегда сохранять фиксированные отступы сверху и слева, а также фиксированный размер, при этом расстояние снизу и справа будут меняться. Это означает, что пустой autoresizingMasks равносилен [.flexibleBottomMargin, .flexibleRightMargin].&lt;/p&gt;&lt;h2 id="autoresizing-interface-builder"&gt;Autoresizing в Interface Builder&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id="translatesautoresizingmaskintoconstraints"&gt;translatesAutoresizingMaskIntoConstraints&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id="-"&gt;Заключение&lt;/h2&gt;</content:encoded></item></channel></rss>