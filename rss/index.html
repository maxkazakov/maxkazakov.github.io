<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Max Kazakov]]></title><description><![CDATA[Блог iOS разработчика]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Max Kazakov</title><link>http://localhost:2368/</link></image><generator>Ghost 2.22</generator><lastBuildDate>Tue, 04 Jun 2019 13:16:36 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[История факапа #1]]></title><description><![CDATA[<p>Планируя работы на февраль 2019 года по основному проекту, на котором работаю, я подумал, что неплохо было бы зарефакторить код, ответственных за парсинг данных. Так вышло, что в процессе рефакторинга, я, сам того не подозревая, заложил в кодовую базу бомбу замедленного действия.</p><h2 id="-">Предыстория</h2><p>2 года назад наша команда внедряла в</p>]]></description><link>http://localhost:2368/qweqwe/</link><guid isPermaLink="false">5cd5d398806356e203eb810f</guid><dc:creator><![CDATA[Max Kazakov]]></dc:creator><pubDate>Fri, 10 May 2019 19:40:25 GMT</pubDate><content:encoded><![CDATA[<p>Планируя работы на февраль 2019 года по основному проекту, на котором работаю, я подумал, что неплохо было бы зарефакторить код, ответственных за парсинг данных. Так вышло, что в процессе рефакторинга, я, сам того не подозревая, заложил в кодовую базу бомбу замедленного действия.</p><h2 id="-">Предыстория</h2><p>2 года назад наша команда внедряла в функционал одного из модулей приложения технологию Couchbase + Sync Gateway. В двух словах: технология позволяет синхронизировать БД между приложением и сервером. Внедряли мы ее с целью избавиться от недостатков http протокола. Идея простая — http запросов для нас нет, есть постоянная синхронизация БД на сервере и на клиенте. Любой запрос на клиенте/ответ сервера клиенту реализуется при помощи записи в БД. Обе стороны слушают изменения в своей БД и реагируют на них должным образом. Такая абстракция позволяет не задумываться о том, в каком состоянии находятся http запросы. Просто настраиваем репликатор (сущность, которая синхронизирует БД) и поехали. Есть недостатки вида "как решать конфликты", "как управлять потоком синхронизации" и т.д., но сегодня не об этом.</p><p>Couchbase Lite (библиотека для работы с БД на устройстве) поддерживает работу с Data Access Object (DTO), например как NSManagedObject в CoreData, или Object в Realm. Но сроки и нежелание чуть больше завязываться на возможности конкретной библиотеки привели нас к быстрому решению использовать Dictionary&lt;String: Any&gt; для мапинга моделей из БД в код и обратно. Поэтому мы написали несколько удобных расширений для этого типа и были довольны. У нас не было уверенности в технологии, мы пробовали, поэтому абстрагирование реализации моделей данных от конкретной реализации БД выглядело логично.</p><h2 id="--1">Работает — не трогай</h2><p>От технологии мы отказались, перешли на новую, самописную (кросплатформенные с++ фреймворки). Переход был быстрым, в том числе благодаря абстрагированию от источника данных. Новая технология не реализует DTO, и отдает нам в качестве моделей голые строки. Т.е. модели в БД представлены строками, а значит, парсим каждый раз при чтении из БД (очевидно, бьет по производительности, но некритично). Это важно отметить, т.к. в дальнейшем это только усилит последствия факапа.</p><p>Парсинг не требовал изменений при переходе, работал отлично. Но было решено переехать на Codable, по ряду причин:</p><!--kg-card-begin: markdown--><ul>
<li>Убрать из процесса парсинга лишнее звено в виде Dictionary</li>
<li>Избавиться от кода в extension Dictionary&lt;String: Any&gt;</li>
<li>Воспользоваться возможностями автогенерации</li>
<li>Сделать парсинг, хорошо понятный любому разработчику</li>
</ul>
<!--kg-card-end: markdown--><h2 id="codable">Codable</h2><p>За пару дней был проведен рефакторинг всех структур данных, их в проекте около 50. Здесь поделюсь парой моментов, которые расстроили, и которые редко описываются в туторах по Codable.</p><p>Структуры данных реализованы как классы, а значит используют наследование. Есть иерархии по 4 наследника. Codable не дает использовать автогенерацию для классов-потомков, чем очень расстроил и вынудил писать (а точнее переписывать) много кода. Причина, по которой так происходит — компилятор не в силах понять, нужно ли классу потомку <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID222">наследовать</a> родительский конструктор или нужно сгенерировать код для Codable. Об этом хорошие размышления <a href="https://forums.swift.org/t/inheriting-from-a-codable-class/14874/3">здесь</a>.</p><p>Второй небольшой, но неприятный момент — Codable не позволяет игнорировать тип данных. Т.е. если по ключу лежит json-объект, то нельзя просто засунуть его в Data/String в процессе парсинга. Иногда хочется забрать данные, а уже потом поглядеть что там в них. Или, к примеру, парсить вложенный объект должны не мы, а кто-то другой. В таких ситуациях может выручить библиотека вроде <a href="https://github.com/Flight-School/AnyCodable">этой</a> либо можно попрактиковаться со своей реализацией. Вот также <a href="http://ilya.puchka.me/codable-in-practice/">отличная статья</a>, где автор описывает проблемы с Codable, возникшие при внедрении в проект.</p><h2 id="--2">Факап</h2><p>Пример кода на swift, который все поломал</p><!--kg-card-begin: markdown--><pre><code>enum State: Int, Decodable {
    case unknown = -1
    case new = 0
    case deleted = 1
}

class Model: Decodable {
    let state: State
    
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.state = (try container.decodeIfPresent(State.self, forKey: .state)) ?? .unknown
    }
    
    enum CodingKeys: CodingKey {
        case state
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>decodeIfPresent может выкинуть единственную ошибку — type mismatch. Приложение упадет, если по ключу лежит тип данных, который мы не ожидаем. В случае с enum типом, неподдерживаемое значение Int в ключе state вызовет падение.</p><p>Так и случилось. На бекенд выкатили обновление с новым кейсом за 5 дней до релиза мобилки, которая этот кейс поддерживает. Старые приложения начали падать. Нужно было срочно решать проблему со стороны бекенда.</p><h2 id="--3">Решение</h2><p>Чтобы правильно понять, где именно нужно фиксить, очень схематично представим как взаимодействуют сервисы и приложения</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="http://localhost:2368/content/images/2019/06/1-2.png" class="kg-image"></figure><!--kg-card-end: image--><p>В этой схеме наша моделька с неподдерживаемым enum-ом летит из прикладных сервисов (Service 1, 2, 3) в сервис событий (Event Service), сохраняется в БД этого сервиса и дальше летит в приложение и сохраняется в локальную БД.</p><p>Решения пошагово:</p><p>1) Выкатываем хотфикс на прикладные сервисы, который отдает по ключу "state" только те значения, которые поддерживаются текущим приложением. Новый, расширенный enum теперь будет передаваться в новом ключе (есть достаточно времени чтобы поддержать новый ключ в грядущих релизах мобилок).</p><p>2) Проходимся скриптом по БД в сервисе событий и делаем фикс аналогичный пункту 1</p><p>Предприняв эти шаги в Firebase продолжают падать краши. Есть некоторая часть пользователей, которые успели в локальную БД затянуть невалидные значения. Проблему можно было бы избежать, если бы при получении данных их сети, мы бы парсили ее в нормальную структуру БД, а не в строку.</p><p>Теперь нужно как-то почистить локальную БД. Обновление приложения решило бы эту проблему, но до релиза еще пара дней. Переустановить приложения обзвонив пользователей — жестко. При логауте чистится локальная БД, значит можно попросить пользователей перелогиниться — но они не могут, т.к. приложение падает сразу же при запуске (падающий модуль запускается первым). Значит можно разлогинить пользователей удаленно. В крашах Firebase находим id пользователей, которые упали, бекендер пишет скрипт для логаута, запускает его. Проблема решена.</p><h2 id="--4">Вместо вывода</h2><p>Причина ошибки не в том, что я слишком строго парсил данные с сервера, а потому что элементарно забыл про обратную совместимость. На мой взгляд, кодогенерация для Codable (например Sourcery) не позволила бы избежать проблем в данном случае, т.к. ошибка была сделана именно на уровне логики парсинга. Учитывая тот факт, что число моделей постоянно растет, есть планы прикрутить кодогенерацию, чтобы в том числе исключить человеческий фактор при рефаторинге кода.</p>]]></content:encoded></item><item><title><![CDATA[Autoresizing Layout]]></title><description><![CDATA[<p>На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS разработчиком, я тратил огромное количество времени на попытки понять принципы работы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов, который помогает iOS разработчику покрыть</p>]]></description><link>http://localhost:2368/autoresizing-layout/</link><guid isPermaLink="false">5cd4125f806356e203eb80c1</guid><category><![CDATA[ios]]></category><category><![CDATA[autolayout]]></category><category><![CDATA[autoresizing]]></category><dc:creator><![CDATA[Max Kazakov]]></dc:creator><pubDate>Thu, 09 May 2019 11:44:18 GMT</pubDate><content:encoded><![CDATA[<p>На мой взгляд, инструменты верстки UI в iOS далеко не идеальны и обладают высоким порогом вхождения (в отличии, например, от html). Будучи начинающим iOS разработчиком, я тратил огромное количество времени на попытки понять принципы работы constraints, циклы layout-a и т.д. Autoresizing — один из инструментов, который помогает iOS разработчику покрыть часть простых кейсов, связанных с версткой. Цель данной статьи — поближе познакомиться с этим инструментом.</p><h2 id="-ios">Способы верстки в iOS</h2><p>На сегодняшний день UIKit предоставляет разработчикам 2 способа управления версткой: ручной (или по-другому верстка на фреймах) и Autolayout.</p><p>Под ручной версткой понимается управление размерами и позицией view вручную, путем изменения свойств <em>frame (</em>либо <em>center</em> и <em>bounds). </em>Как правило, данный способ реализуется при помощи переопределения метода <em>layoutSubviews </em>UIView, на момент вызова которого, нам известно свойство bounds текущего экземпляра. В этом методе мы <em>вручную </em>определяем позицию и размеры дочерних вью.</p><p>Autolayout использует набор ограничений (constraints), которые описывают, как будут располагаться вью относительно друг друга. В отличие от ручного способа, здесь нет необходимости высчитывать <em>frame</em> каждый раз, когда в нашей верстке что-то изменилось, Autolayout сделает это за нас. Данный способ также допускает ручную настройку <em>frame</em> в случае, если мы хотим подкорректировать результат лейаута. Для этого нужно переопределить <em>layoutSubviews, </em>вызывать родительскую реализацию этого метода (здесь дочерние вью получат свои размеры из движка Autolayout), скорректировать фреймы дочерних вью.</p><p>Каждый из способов обладает своими преимуществами и недостатками, описание которых достойно отдельной статьи, мы же остановим наше внимание на Autoresizing.</p><h2 id="-autoresizing">Основные принципы Autoresizing</h2><p>Autoresizing работает всегда, когда мы решили использовать ручную верстку (и в некоторых случаях при использовании Autolayout, но об этом чуть позже). Autoresizing основан на двух основных понятиях: springs (пружины) и struts (распорки). Перевод этих терминов точно отражает их смысл: springs — что-то, что растягивается, struts — что-то, что всегда имеет фиксированный размер. Данные понятия применимы к следующим <strong>параметрам разметки</strong>:<br>1) Внутренние — Width, Height. Описывают размер вью.<br>2) Внешние — Left, Right, Top, Bottom. Описывают положение вью внутри родителя — отступ от левого, правого, верхнего и нижнего края соответственно.</p><p>Рассмотрим простой пример того, как это работает. Допустим, у нас есть задача: необходимо, чтобы дочерняя вью всегда располагалась по центру родительской и пропорционально изменяла размер при изменении размера родителя (Рис. 1). Решением в данном случае будет установить struts для всех внешних параметров, и springs для всех внутренних параметров.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/05/center-resize.gif" class="kg-image"><figcaption>Рис. 1. Синий прямоугольник — родительская вью, красный — дочерняя.</figcaption></figure><!--kg-card-end: image--><p>Другой пример: необходимо разместить вью с фиксированным размером в правом нижнем углу родительской вью (Рис. 2). Для это необходимо установить struts для параметров Right и Bottom, а также для всех внутренних параметров, т.к. расстояния от нижнего и правого края до родителя и размер нашей вью строго зафиксированы. Также нужно установить springs для Left и Top, т.к. эти параметры будут изменяться при изменении размеров родительской вью.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/05/topleft.gif" class="kg-image"><figcaption>Рис. 2. Вью с фиксированным размером и привязкой к правому нижнему углу</figcaption></figure><!--kg-card-end: image--><h2 id="autoresizing-">Autoresizing в коде</h2><p>Единственный способ регулировать Autoresizing в коде — свойство <em>autoresizingMask </em>у UIView. Данное свойство имеет тип OptionSet со следующим набором опций:</p><!--kg-card-begin: markdown--><ul>
<li>flexibleLeftMargin</li>
<li>flexibleWidth</li>
<li>flexibleRightMargin</li>
<li>flexibleTopMargin</li>
<li>flexibleHeight</li>
<li>flexibleBottomMargin</li>
</ul>
<!--kg-card-end: markdown--><p>Как данное свойство соотносится со stings и struts, внешними и внутренними параметрами разметки? <em>Каждая опция в</em> <em>autoresizingMask — это </em>springs<em> для определенного параметра, а отсутствие опции — автоматически означает struts.</em></p><p>Теперь попробуем решить первую задачу с центрированием дочерней вью (Рис. 1). Для этого нам необходимо задать свойство autoresizingMask, как показано на фрагменте кода ниже. </p><!--kg-card-begin: markdown--><pre><code>    // Создаем родительскую view
    let v1 = UIView(frame: CGRect(x: 100, y: 250, width: 200, height: 200))
    v1.backgroundColor = .blue
    
    // Создаем дочернюю вью
    let v2 = UIView(frame: v1.bounds.insetBy(dx: 30, dy: 30))
    v2.backgroundColor = .red
    
    // Добавление в иерархию
    self.view.addSubview(v1)
    v1.addSubview(v2)
    
    // Устанавливаем autoresizing
    v2.autoresizingMask = [.flexibleWidth, .flexibleHeight]
</code></pre>
<!--kg-card-end: markdown--><p>Установив значение свойства [.flexibleWidth, .flexibleHeight], мы говорим, что хотим сделать изменяемые значения для параметров width и height (springs), а для остальных свойств оставить фиксированные значения (struts).</p><p>Вторая задача решается при помощи задания значения [.flexibleTopMargin, .flexibleLeftMargin]. Мы не указали в опциях размер, а также нижний и правый отступ, а значит, эти параметры будут оставаться постоянными (Рис. 2).</p><p>По умолчанию свойство autoresizingMasks является пустым. Что произойдет, если оставить значение по умолчанию? Дочерняя вью будет всегда сохранять фиксированные отступы сверху и слева, а также фиксированный размер, при этом расстояние снизу и справа будут меняться. Это означает, что пустой autoresizingMasks равносилен [.flexibleBottomMargin, .flexibleRightMargin].</p><h2 id="autoresizing-interface-builder">Autoresizing в Interface Builder</h2><p>Interface Builder также позволяет конфигурировать autoresizingMasks. Для этого необходимо перейти во вкладку Size Inspectors, редактор Autoresizing выглядит как показано на рисунке ниже.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/05/image.png" class="kg-image"><figcaption>Рис 3. Редактирование Autoresizing в Interface Builder</figcaption></figure><!--kg-card-end: image--><p>Здесь активные внешние параметры означают struts, неактивные — springs. Для внутренних параметров все ровно наоборот.</p><h2 id="translatesautoresizingmaskintoconstraints">translatesAutoresizingMaskIntoConstraints</h2><p>Вью начинает быть задействованной в расчете на Autolayout как только мы добавили ей или одной из ее дочерних вью constraint. В таком случае, если задать constraints только для дочерней вью, но не задавать для родительской, мы можем получить предупреждение, которое сообщает о том, что для родительской вью Autolayout не смог определить размер и позицию ("Position and size are ambiguous"). Такая ситуация могла возникнуть когда Autolayout только появился в iOS — новые вью верстались с использованием constraints, а старые оставались на ручном лейауте (он же Autoresizing, как мы выяснили ранее). Для того, чтобы избежать этого, разработчики Apple ввели свойство translatesAutoresizingMaskIntoConstraints. Если свойство имеет значение true, то для вью будут автоматически созданы constraints, которые однозначно определяют позицию и размер. Во View Hierarchy мы можем увидеть автоматически сгенерированные constraints.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="http://localhost:2368/content/images/2019/05/image-1.png" class="kg-image"><figcaption>Рис. 4. Автоматически сгенерированные constraints</figcaption></figure><!--kg-card-end: image--><p>Значение false отключает эту магию. При создании вью из кода — значение свойства — true, при создании из xib/storyboard — false. В Interface Builder свойство регулируется при помощи флага “Use Auto Layout", которое является инвертированным значением translatesAutoresizingMaskIntoConstraints.</p><p>Очень часто возникает ситуация, когда мы хотим создать нашу вью из кода и сверстать ее на Autolayout, т.е. явно задать ей constraints. Чтобы наши и автоматически сгенерированные constraints не конфликтовали, необходимо задать значение translatesAutoresizingMaskIntoConstraints в false.</p><h2 id="-">Заключение</h2><p>Очевидно, что с приходом Autolayout механизм Autoresizng утратил актуальность. Однако, его понимание необходимо как минимум, чтобы осознанно избегать конфликтов c constraints. Также данных механизм может быть полезен для простой верстки вью относительно родителя.</p>]]></content:encoded></item></channel></rss>